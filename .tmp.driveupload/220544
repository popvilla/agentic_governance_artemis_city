

import React, { useState, useEffect, useCallback, useMemo } from 'react';
import saveAs from 'file-saver';
import JSZip from 'jszip';
import { v4 as uuidv4 } from 'uuid';

import Header from './components/Header';
import FileExplorer from './components/FileExplorer';
import CodeEditor from './components/CodeEditor';
import { Preview } from './components/Preview';
import ChatPanel from './components/ChatPanel';
import { SourceControlView } from './components/SourceControlView';
import KnowledgeBaseManager from './components/KnowledgeBaseManager';
import SnippetManager from './components/SnippetManager';
import { GenerateAppModal } from './components/GenerateAppModal';
import FeedbackPanel from './components/FeedbackPanel';
import PanelFrame from './components/PanelFrame';
import SplitViewPanel from './components/SplitViewPanel';
import { Accordion, AccordionItem } from './components/Accordion';

import { BotIcon, CodeIcon, EyeIcon, GitBranchIcon, BookTextIcon, FolderGit2, LightbulbIcon, ClipboardSignature } from './components/icons';
import { File as FileType, Folder, Change, Commit, ChatMessage, MessageSender, URLGroup, ReviewResult, Snippet } from './types';
import { generateAppFromPrompt, getChatResponse, getReviewFeedback, formatCode } from './services/geminiService';
import { calculateChanges } from './utils'; // Moved to utils
import { SUPPORTED_LANGUAGES } from './components/constants';

const INITIAL_COMMIT_ID = '00000000-0000-0000-0000-000000000000';

const buildFileTree = (files: Record<string, string>): Folder => {
  const root: Folder = { name: 'root', path: '.', children: [] };
  Object.entries(files).forEach(([path, content]) => {
    const parts = path.split('/');
    let currentLevel = root.children;
    let currentPath = '';

    parts.forEach((part, index) => {
      currentPath = currentPath ? `${currentPath}/${part}` : part;
      if (index === parts.length - 1) { // It's a file
        currentLevel.push({ name: part, path: currentPath, content });
      } else { // It's a directory
        let dir = currentLevel.find(c => c.name === part && 'children' in c) as Folder | undefined;
        if (!dir) {
          dir = { name: part, path: currentPath, children: [] };
          currentLevel.push(dir);
        }
        currentLevel = dir.children;
      }
    });
  });
  return root;
};

const findFileInTree = (path: string, tree: Folder): FileType | null => {
  const parts = path.split('/');
  let current: Folder | FileType | undefined = tree;
  for (const part of parts) {
    if (current && 'children' in current) {
      current = current.children.find(c => c.name === part);
    } else {
      return null;
    }
  }
  return current && 'content' in current ? current : null;
};

// More performant update function that avoids deep copying the entire tree.
const updateFileInTree = (path: string, newContent: string, tree: Folder): Folder => {
    const parts = path.split('/');
    
    // Recursively update the tree
    const updateNode = (node: Folder | FileType): Folder | FileType => {
        // If it's the file we're looking for
        if (node.path === path && 'content' in node) {
            return { ...node, content: newContent };
        }
        
        // If it's a folder, check if the path is within its children
        if ('children' in node && path.startsWith(node.path === '.' ? '' : node.path)) {
            let hasChanged = false;
            const newChildren = node.children.map(child => {
                const updatedChild = updateNode(child);
                if (updatedChild !== child) {
                    hasChanged = true;
                }
                return updatedChild;
            });

            if (hasChanged) {
                return { ...node, children: newChildren };
            }
        }
        
        return node;
    };

    return updateNode(tree) as Folder;
};

const flattenFileTree = (node: Folder | FileType): Record<string, string> => {
    let files: Record<string, string> = {};
    if ('children' in node) {
        for (const child of node.children) {
            files = { ...files, ...flattenFileTree(child) };
        }
    } else {
        files[node.path] = node.content;
    }
    return files;
};

const App: React.FC = () => {
  const welcomeFiles = {
    "index.html": `<!DOCTYPE html>
<html>
  <head>
    <title>Welcome to Gemini AI IDE</title>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <h1>Welcome!</h1>
    <p>Click the "Generate App" button to start a new project.</p>
    <script src="script.js"></script>
  </body>
</html>`,
    "style.css": `body { font-family: sans-serif; text-align: center; padding: 2rem; }`,
    "script.js": `console.log("Welcome to the IDE!");`
  };

  const initialCommit: Commit = {
    id: INITIAL_COMMIT_ID,
    message: "Initial commit",
    timestamp: new Date().toISOString(),
    files: welcomeFiles,
  };
  
  const [fileTree, setFileTree] = useState<Folder>(() => buildFileTree(welcomeFiles));
  const [activeFilePath, setActiveFilePath] = useState<string | null>('index.html');
  const [isGenerating, setIsGenerating] = useState(false);
  const [isModalOpen, setIsModalOpen] = useState(false);
  
  const [theme, setTheme] = useState<'light' | 'dark' | 'matrix' | 'glass-robo'>('dark');

  useEffect(() => {
    const themes = ['dark', 'theme-matrix', 'theme-glass-robo'];
    themes.forEach(t => document.documentElement.classList.remove(t));

    if (theme === 'dark') {
      document.documentElement.classList.add('dark');
    } else if (theme === 'matrix') {
      document.documentElement.classList.add('theme-matrix');
    } else if (theme === 'glass-robo') {
      document.documentElement.classList.add('theme-glass-robo');
    }
    // 'light' theme has no class, so it's the default
  }, [theme]);

  // Layout and sidebar states
  const [currentLayout, setCurrentLayout] = useState<'panel' | 'grid' | 'split'>('panel');
  const [activeSplitPanel, setActiveSplitPanel] = useState<'preview' | 'chat' | 'review'>('preview');

  const [commits, setCommits] = useState<Commit[]>([initialCommit]);
  const [stagedChanges, setStagedChanges] = useState<Change[]>([]);
  
  const [messages, setMessages] = useState<ChatMessage[]>([
    { id: '1', sender: MessageSender.MODEL, text: "Hello! I'm your AI assistant. Ask me anything about your code or describe an app you want to build." }
  ]);
  const [isChatLoading, setIsChatLoading] = useState(false);

  // State for code review feature
  const [reviewResult, setReviewResult] = useState<ReviewResult | null>(null);
  const [isReviewLoading, setIsReviewLoading] = useState(false);
  const [reviewError, setReviewError] = useState<string | null>(null);
  const [isMakingItRun, setIsMakingItRun] = useState(false);
  const [isFormatting, setIsFormatting] = useState(false);

  const [urlGroups, setUrlGroups] = useState<URLGroup[]>([{id: 'default', name: 'Default Group', urls: []}]);
  const [activeUrlGroupId, setActiveUrlGroupId] = useState('default');
  
  const [snippets, setSnippets] = useState<Snippet[]>([
    { id: '1', name: 'React Component', language: 'typescript', code: `import React from 'react';\n\nconst MyComponent: React.FC = () => {\n  return (\n    <div>\n      \n    </div>\n  );\n};\n\nexport default MyComponent;` },
    { id: '2', name: 'Fetch API Call', language: 'javascript', code: `fetch('https://api.example.com/data')\n  .then(response => response.json())\n  .then(data => console.log(data))\n  .catch(error => console.error('Error:', error));` }
  ]);
  const [snippetToInsert, setSnippetToInsert] = useState<{ id: string, code: string } | null>(null);

  const headCommit = useMemo(() => commits[commits.length - 1], [commits]);
  const workingFiles = useMemo(() => flattenFileTree(fileTree), [fileTree]);

  const workingDirChanges = useMemo(() => {
    const headFiles = headCommit?.files ?? {};
    const allChanges = calculateChanges(headFiles, workingFiles);
    return allChanges.filter(c => !stagedChanges.some(sc => sc.path === c.path));
  }, [workingFiles, headCommit, stagedChanges]);

  const activeFile = useMemo(() => {
    return activeFilePath ? findFileInTree(activeFilePath, fileTree) : null;
  }, [activeFilePath, fileTree]);
  
  const handleGenerateApp = async (prompt: string) => {
    setIsGenerating(true);
    setMessages(prev => [...prev, { id: uuidv4(), sender: MessageSender.USER, text: `Generate an app: ${prompt}` }, { id: uuidv4(), sender: MessageSender.MODEL, text: "Generating your application...", isLoading: true }]);
    try {
      const files = await generateAppFromPrompt(prompt);
      const newCommit: Commit = {
        id: uuidv4(),
        message: `feat: Generate app for "${prompt.substring(0, 50)}..."`,
        timestamp: new Date().toISOString(),
        files: files
      };
      setFileTree(buildFileTree(files));
      setCommits([initialCommit, newCommit]);
      setStagedChanges([]);
      setActiveFilePath(Object.keys(files).find(p => p.toLowerCase().includes('index.html')) || Object.keys(files)[0] || null);
      setIsModalOpen(false);
      setMessages(prev => prev.filter(m => !m.isLoading).concat([{id: uuidv4(), sender: MessageSender.SYSTEM, text: "App generated successfully!" }]));
      setActiveSplitPanel('preview');
    } catch (error) {
      console.error(error);
      const errorMessage = error instanceof Error ? error.message : "An unknown error occurred.";
      setMessages(prev => prev.filter(m => !m.isLoading).concat([{id: uuidv4(), sender: MessageSender.SYSTEM, text: `Error generating app: ${errorMessage}` }]));
    } finally {
      setIsGenerating(false);
    }
  };

  const handleFileContentChange = useCallback((newContent: string) => {
    // Guard against non-string values (e.g. Events) corrupting state
    if (typeof newContent !== 'string') {
        console.error("handleFileContentChange received non-string content:", newContent);
        return;
    }

    if (activeFilePath) {
      setFileTree(prevTree => updateFileInTree(activeFilePath, newContent, prevTree));
    }
  }, [activeFilePath]);
  
  const handleStage = useCallback((change: Change) => {
    setStagedChanges(prev => [...prev, change]);
  }, []);
  
  const handleUnstage = useCallback((change: Change) => {
    setStagedChanges(prev => prev.filter(c => c.path !== change.path));
  }, []);
  
  const handleCommit = useCallback((message: string) => {
    if (stagedChanges.length === 0) return;
    
    const newHeadFiles = { ...headCommit.files };
    stagedChanges.forEach(change => {
        if (change.type === 'deleted') {
            delete newHeadFiles[change.path];
        } else {
            newHeadFiles[change.path] = workingFiles[change.path];
        }
    });
    
    const newCommit: Commit = {
        id: uuidv4(),
        message,
        timestamp: new Date().toISOString(),
        files: newHeadFiles,
    };
    
    setCommits(prev => [...prev, newCommit]);
    setStagedChanges([]);
  }, [stagedChanges, headCommit, workingFiles]);

  const handleCheckout = useCallback((commitId: string) => {
    const commit = commits.find(c => c.id === commitId);
    if (commit) {
        const commitIndex = commits.findIndex(c => c.id === commitId);
        const newCommits = commits.slice(0, commitIndex + 1);

        setFileTree(buildFileTree(commit.files));
        setCommits(newCommits);
        setStagedChanges([]);
    }
  }, [commits]);
  
  const handleSendMessage = async (message: string) => {
    const newUserMessage: ChatMessage = { id: uuidv4(), sender: MessageSender.USER, text: message };
    const loadingMessage: ChatMessage = { id: uuidv4(), sender: MessageSender.MODEL, text: "Thinking...", isLoading: true };
    setMessages(prev => [...prev, newUserMessage, loadingMessage]);
    setIsChatLoading(true);

    try {
        const activeGroup = urlGroups.find(g => g.id === activeUrlGroupId);
        const contextUrls = activeGroup ? activeGroup.urls : [];
        const chatHistory = messages
          .filter(m => m.sender === MessageSender.USER || m.sender === MessageSender.MODEL)
          .map(m => ({
              role: m.sender as ('user' | 'model'),
              parts: [{ text: m.text }]
          }));
        
        const responseText = await getChatResponse([...chatHistory, {role: 'user', parts: [{text: message}]}], contextUrls);
        const newModelMessage: ChatMessage = { id: uuidv4(), sender: MessageSender.MODEL, text: responseText };
        setMessages(prev => prev.filter(m => !m.isLoading).concat([newModelMessage]));

    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : "An unknown error occurred.";
        const newSystemMessage: ChatMessage = { id: uuidv4(), sender: MessageSender.SYSTEM, text: `Error: ${errorMessage}` };
        setMessages(prev => prev.filter(m => !m.isLoading).concat([newSystemMessage]));
    } finally {
        setIsChatLoading(false);
    }
  };

  const executeCodeReview = useCallback(async (allFiles: Record<string, string>, filePath: string | null) => {
    setIsReviewLoading(true);
    setReviewError(null);
    setReviewResult(null);
    setActiveSplitPanel('review'); // Ensure split view changes tab

    try {
        const result = await getReviewFeedback(allFiles, filePath);
        setReviewResult(result);
    } catch (error) {
        console.error("Error during code review:", error);
        setReviewError(error instanceof Error ? error.message : "An unknown error occurred during code review.");
    } finally {
        setIsReviewLoading(false);
    }
  }, []);

  const handleReviewCode = useCallback(async () => {
    if (!activeFile) {
        setReviewError("No active file selected to review. Please select a file or use the custom code input.");
        setReviewResult(null);
        setActiveSplitPanel('review');
        return;
    }
    await executeCodeReview(workingFiles, activeFile.path);
  }, [activeFile, executeCodeReview, workingFiles]);

  const handleReviewCustomCode = useCallback(async (code: string, language: string) => {
      if (!code.trim()) {
          setReviewError("No code provided for custom review.");
          setReviewResult(null);
          setActiveSplitPanel('review');
          return;
      }
      
      const languageDetails = SUPPORTED_LANGUAGES.find(lang => lang.value === language);
      const extension = languageDetails?.extensions[0] || 'txt';
      const fileName = `custom_snippet.${extension}`;

      // Pass the entire project as context, with the custom snippet as the "active file"
      const filesForReview = { ...workingFiles, [fileName]: code };
      await executeCodeReview(filesForReview, fileName);
  }, [executeCodeReview, workingFiles]);
  
  const handleFormatCode = useCallback(async () => {
    if (!activeFile) return;

    setIsFormatting(true);
    try {
        const languageInfo = SUPPORTED_LANGUAGES.find(l => 
            l.extensions.some(ext => activeFile.path.endsWith(`.${ext}`))
        );
        const language = languageInfo?.value || 'plaintext';

        if (language === 'plaintext') {
            console.log("Cannot format a plaintext file.");
            return;
        }

        const formattedCode = await formatCode(activeFile.content, language);
        handleFileContentChange(formattedCode);
    } catch (error) {
        // Here you could show an error toast to the user
        console.error("Failed to format code:", error);
    } finally {
        setIsFormatting(false);
    }
  }, [activeFile, handleFileContentChange]);

  const handleApplySuggestion = useCallback((newCode: string) => {
    if (activeFilePath) {
      handleFileContentChange(newCode);
    }
  }, [activeFilePath, handleFileContentChange]);

  const handleMakeItRun = useCallback(async (suggestedCode: string) => {
    if (!activeFile && !suggestedCode) {
        setReviewError("No active file selected or suggested code available to 'make it run'.");
        setReviewResult(null);
        setActiveSplitPanel('review');
        return;
    }
    setIsMakingItRun(true);
    setReviewError(null);
    setReviewResult(null);
    setActiveSplitPanel('review');

    try {
        let codeToReviewAfterApply = suggestedCode;
        let pathForReview = activeFilePath;
        let allFilesForReview = { ...workingFiles };

        if (activeFilePath && suggestedCode) {
            handleFileContentChange(suggestedCode);
            codeToReviewAfterApply = suggestedCode;
            allFilesForReview[activeFilePath] = suggestedCode;
        } else if (activeFile) {
            codeToReviewAfterApply = activeFile.content;
            pathForReview = activeFile.path;
        } else {
             setReviewError("Cannot 'make it run': no active file and no suggested code.");
             return;
        }

        const result = await getReviewFeedback(allFilesForReview, pathForReview);
        setReviewResult(result);
    } catch (error) {
        console.error("Error during 'make it run' review:", error);
        setReviewError(error instanceof Error ? error.message : "An unknown error occurred while trying to make it run.");
    } finally {
        setIsMakingItRun(false);
    }
  }, [activeFile, activeFilePath, handleFileContentChange, getReviewFeedback, workingFiles]);
  
  const handleAddUrl = (url: string) => {
    setUrlGroups(prev => prev.map(g => g.id === activeUrlGroupId ? {...g, urls: [...g.urls, url]} : g));
  };
  
  const handleRemoveUrl = (url: string) => {
     setUrlGroups(prev => prev.map(g => g.id === activeUrlGroupId ? {...g, urls: g.urls.filter(u => u !== url)} : g));
  };
  
  const handleCreateUrlGroup = (name: string) => {
      const newGroup: URLGroup = { id: uuidv4(), name, urls: [] };
      setUrlGroups(prev => [...prev, newGroup]);
      setActiveUrlGroupId(newGroup.id);
  };

  const handleAddSnippet = (name: string, language: string, code: string) => {
    const newSnippet: Snippet = { id: uuidv4(), name, language, code };
    setSnippets(prev => [...prev, newSnippet]);
  };
  const handleDeleteSnippet = (id: string) => {
      setSnippets(prev => prev.filter(s => s.id !== id));
  };
  const handleInsertSnippet = (code: string) => {
      setSnippetToInsert({ id: uuidv4(), code });
  };
  
  const handleDownload = async () => {
      const zip = new JSZip();
      Object.entries(workingFiles).forEach(([path, content]) => {
          zip.file(path, content);
      });
      const blob = await zip.generateAsync({ type: 'blob' });
      saveAs(blob, "gemini-ide-export.zip");
  };

  const activeFileLanguage = useMemo(() => {
    if (!activeFile?.path) return 'plaintext';
    const languageInfo = SUPPORTED_LANGUAGES.find(l => 
        l.extensions.some(ext => activeFile.path.endsWith(`.${ext}`))
    );
    return languageInfo?.value || 'plaintext';
  }, [activeFile]);

  const EditorPanel = (
    <div className="flex flex-col h-full">
      {activeFile ? (
        <>
          <div className="flex-shrink-0 p-2 border-b border-slate-300 dark:border-slate-700 text-sm text-slate-500 dark:text-slate-400 font-mono flex items-center gap-2">
            <CodeIcon className="w-4 h-4" /> {activeFile.path}
          </div>
          <div className="flex-grow h-full">
            <CodeEditor 
              content={activeFile.content} 
              onChange={handleFileContentChange}
              snippetToInsert={snippetToInsert}
              onSnippetInserted={() => setSnippetToInsert(null)}
              language={activeFileLanguage}
            />
          </div>
        </>
      ) : (
        <div className="flex items-center justify-center h-full text-slate-400 dark:text-slate-500">Select a file to begin editing.</div>
      )}
    </div>
  );

  return (
    <div className="h-screen w-screen bg-slate-100 dark:bg-slate-900 text-slate-900 dark:text-slate-200 flex flex-col font-sans overflow-hidden">
      <Header
        onGenerateAppClick={() => setIsModalOpen(true)}
        onReviewCodeClick={handleReviewCode}
        onFormatCodeClick={handleFormatCode}
        isFormatting={isFormatting}
        onDownload={handleDownload}
        onLayoutChange={setCurrentLayout}
        currentLayout={currentLayout}
        theme={theme}
        onThemeChange={setTheme}
      />
      <main className={`flex-grow flex overflow-hidden ${currentLayout === 'grid' ? 'grid grid-cols-3 grid-rows-2 gap-px bg-slate-300 dark:bg-slate-700/50' : currentLayout === 'split' ? 'grid grid-cols-2 gap-px bg-slate-300 dark:bg-slate-700/50' : ''}`}>
        {currentLayout === 'panel' && (
          <>
            <aside className="w-1/5 h-full min-w-[250px] max-w-[400px] bg-slate-200/50 dark:bg-slate-800/50 border-r border-slate-300 dark:border-slate-700 flex flex-col">
              <Accordion>
                <AccordionItem title="File Explorer" icon={<FolderGit2 className="w-4 h-4" />} initialOpen={true}>
                  <div className="flex-grow overflow-y-auto">
                    <FileExplorer node={fileTree} onSelectFile={setActiveFilePath} activeFile={activeFilePath} />
                  </div>
                </AccordionItem>
                <AccordionItem title="Source Control" icon={<GitBranchIcon className="w-4 h-4" />}>
                  <SourceControlView workingDirChanges={workingDirChanges} stagedChanges={stagedChanges} commits={commits} onStage={handleStage} onUnstage={handleUnstage} onCommit={handleCommit} onCheckout={handleCheckout} />
                </AccordionItem>
                <AccordionItem title="Snippets" icon={<ClipboardSignature className="w-4 h-4" />}>
                  <SnippetManager 
                    snippets={snippets}
                    onAdd={handleAddSnippet}
                    onDelete={handleDeleteSnippet}
                    onInsert={handleInsertSnippet}
                  />
                </AccordionItem>
                <AccordionItem title="Knowledge Base" icon={<BookTextIcon className="w-4 h-4" />}>
                  <KnowledgeBaseManager urls={urlGroups.find(g=>g.id === activeUrlGroupId)?.urls || []} onAddUrl={handleAddUrl} onRemoveUrl={handleRemoveUrl} urlGroups={urlGroups} activeUrlGroupId={activeUrlGroupId} onSetGroupId={setActiveUrlGroupId} onCreateUrlGroup={handleCreateUrlGroup}/>
                </AccordionItem>
              </Accordion>
            </aside>
            <div className="flex-grow h-full border-x border-slate-300 dark:border-slate-700 flex flex-col">{EditorPanel}</div>
            <aside className="w-2/5 h-full min-w-[300px] bg-slate-200/50 dark:bg-slate-800/50 border-l border-slate-300 dark:border-slate-700 flex flex-col">
              <Accordion>
                <AccordionItem title="Preview" icon={<EyeIcon className="w-4 h-4" />} initialOpen={true}>
                  <Preview fileTree={fileTree} />
                </AccordionItem>
                <AccordionItem title="Chat" icon={<BotIcon className="w-4 h-4" />}>
                  <ChatPanel messages={messages} onSendMessage={handleSendMessage} isLoading={isChatLoading} />
                </AccordionItem>
                <AccordionItem title="Code Review" icon={<LightbulbIcon className="w-4 h-4" />}>
                  <FeedbackPanel
                    reviewResult={reviewResult}
                    isLoading={isReviewLoading}
                    error={reviewError}
                    onApplySuggestion={handleApplySuggestion}
                    onMakeItRun={handleMakeItRun}
                    isMakingItRun={isMakingItRun}
                    onReviewCustomCode={handleReviewCustomCode}
                  />
                </AccordionItem>
              </Accordion>
            </aside>
          </>
        )}

        {currentLayout === 'grid' && (
          <>
            <PanelFrame title="File Explorer" icon={<FolderGit2 className="w-4 h-4" />}>
              <div className="flex-grow overflow-y-auto">
                <FileExplorer node={fileTree} onSelectFile={setActiveFilePath} activeFile={activeFilePath} />
              </div>
            </PanelFrame>
            <PanelFrame title="Editor" icon={<CodeIcon className="w-4 h-4" />}>
              {EditorPanel}
            </PanelFrame>
            <PanelFrame title="Preview" icon={<EyeIcon className="w-4 h-4" />}>
              <Preview fileTree={fileTree} />
            </PanelFrame>
            <PanelFrame title="Source Control" icon={<GitBranchIcon className="w-4 h-4" />}>
              <SourceControlView workingDirChanges={workingDirChanges} stagedChanges={stagedChanges} commits={commits} onStage={handleStage} onUnstage={handleUnstage} onCommit={handleCommit} onCheckout={handleCheckout} />
            </PanelFrame>
            <PanelFrame title="Chat" icon={<BotIcon className="w-4 h-4" />}>
              <ChatPanel messages={messages} onSendMessage={handleSendMessage} isLoading={isChatLoading} />
            </PanelFrame>
            <PanelFrame title="Code Review" icon={<LightbulbIcon className="w-4 h-4" />}>
              <FeedbackPanel
                reviewResult={reviewResult}
                isLoading={isReviewLoading}
                error={reviewError}
                onApplySuggestion={handleApplySuggestion}
                onMakeItRun={handleMakeItRun}
                isMakingItRun={isMakingItRun}
                onReviewCustomCode={handleReviewCustomCode}
              />
            </PanelFrame>
          </>
        )}

        {currentLayout === 'split' && (
          <>
            <div className="flex-grow h-full flex flex-col">{EditorPanel}</div>
            <SplitViewPanel
              fileTree={fileTree}
              messages={messages}
              onSendMessage={handleSendMessage}
              isChatLoading={isChatLoading}
              reviewResult={reviewResult}
              isLoading={isReviewLoading}
              error={reviewError}
              onApplySuggestion={handleApplySuggestion}
              onMakeItRun={handleMakeItRun}
              isMakingItRun={isMakingItRun}
              onReviewCustomCode={handleReviewCustomCode}
              activePanel={activeSplitPanel}
              onSelectPanel={setActiveSplitPanel}
            />
          </>
        )}
      </main>
      <GenerateAppModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        onSubmit={handleGenerateApp}
        isLoading={isGenerating}
      />
    </div>
  );
};

export default App;
