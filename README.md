Artemis City

> **Purpose:** This document provides comprehensive context for AI assistants (like Claude) working with the Artemis City codebase. It explains the project structure, philosophy, key conventions, and development workflows to ensure consistent and informed assistance.

---

## Table of Contents

1. [Project Overview](#project-overview)
   - [Version History](#version-history)
   - [Project Metadata](#project-metadata)
   - [Mission Statement][mission-statement] 
2. [Quick Start & Security Setup](#quick-start--security-setup)
   - [Secure Environment Setup](#secure-environment-setup)
   - [Running Artemis City](#running-artemis-city)
   - [Key Documentation](#key-documentation)
   - [Security Best Practices](#security-best-practices)
3. [Core Philosophy & Principles](#core-philosophy--principles)
   - [Mission Statement][mission-statement]
   - [Core Principles](#core-principles)
4. [Repository Structure](#repository-structure)
5. [Agent System Architecture](#agent-system-architecture)
6. [Key Protocols & Models](#key-protocols--models)
7. [Development Workflows](#development-workflows)
8. [Coding Conventions](#coding-conventions)
9. [Important Files Reference](#important-files-reference)
10. [Working with This Codebase](#working-with-this-codebase)
11. [Communication Patterns](#communication-patterns)
12. [Security Best Practices](#security-best-practices)

---

## Project Overview

**Artemis City** is an architectural framework designed to align agentic reasoning with transparent, accountable action across distributed intelligence systemsâ€”both human and machine. This is **Version 0.1.0**, providing foundational scaffolding for:

- Defining agents with clear roles and boundaries
- Managing memory with trust decay models
- Establishing secure communication interfaces
- Simulating environments for testing agent interactions

### Key Metadata
- **Project Name:** Artemis City (agentic-codex)
- **Version:** 0.1.0
- **License:** MIT
- **Primary Language:** Python 3.8+
- **Main Entry Point:** `main.py`
- **Author:** Generated by Prinston Palmer

### Mission Statement
Balance **trust**, **entropy**, and **collaboration** to achieve "net good over noise" through iterative clarity and accountable collaboration.

---

## Quick Start & Security Setup

###  Secure Environment Setup (Required First Step)

Before running Artemis City, you must configure environment variables securely:

```bash
# Run the automated setup script
./setup_secrets.sh
```

This script will:
- Create `.env` files from templates
- Generate secure API keys automatically
- Set proper file permissions (600)
- Verify gitignore protection

**Manual Setup:**
```bash
# Copy environment templates
cp .env.example .env
cd "Artemis Agentic Memory Layer "
cp .env.example .env
cd ..

# Generate secure API key
openssl rand -hex 32  # Use this value for MCP_API_KEY in both .env files

# Set secure permissions
chmod 600 .env
chmod 600 "Artemis Agentic Memory Layer /.env"
```

###  Running Artemis City

**1. Install Python dependencies:**
```bash
python -m venv .venv
source .venv/bin/activate  # macOS/Linux
pip install -r requirements.txt
```

**2. Start the MCP Memory Server:**
```bash
cd "Artemis Agentic Memory Layer "
npm install
npm run dev
```

**3. Run the CLI (in another terminal):**
```bash
source .venv/bin/activate
python main.py
```

**4. Try the demos:**
```bash
# City postal system demo
python demo_city_postal.py

# Memory integration demo
python demo_memory_integration.py

# Artemis persona features
python demo_artemis.py
```

###  Key Documentation

- **[SECURITY.md](SECURITY.md)** - Comprehensive security best practices
- **[WARP.md](WARP.md)** - Development guide for AI assistants
- **[LIVING_CITY.md](LIVING_CITY.md)** - Living city metaphor guide
- **[MEMORY_INTEGRATION.md](MEMORY_INTEGRATION.md)** - Memory layer architecture
- **[ARTEMIS_FEATURES.md](ARTEMIS_FEATURES.md)** - Persona system documentation

 **IMPORTANT**: Never commit `.env` files or any files containing secrets to version control!

---

## Core Philosophy & Principles

The project follows the **Codex Manifesto** (`codex/manifesto.md`), which establishes these core tenets:

### 1. **Iterative Clarity, Not Static Truth**
- The Codex is a living document
- Evolves with understanding and experience
- Embrace continuous improvement

### 2. **Net Good Over Noise**
- Prioritize actions that contribute positively to system goals
- Filter information through ethical boundaries
- Focus on meaningful contributions

### 3. **Transparent Accountability**
- Every agent's actions are auditable and attributable
- Clear documentation of roles and responsibilities
- Traceable decision-making processes

### 4. **Collaborative Autonomy**
- Agents operate with defined autonomy within a collaborative framework
- Clear boundaries prevent scope creep
- Interdependencies are explicitly defined

### 5. **Resilience through Entropy Management**
- Acknowledge natural decay and drift in complex systems
- Implement countermeasures proactively
- Use Trust Decay Model to manage reliability

---
   
   ## Repository Structure
   
   ```
   Artemis-City/
   â”‚
   â”œâ”€â”€ agents/                    # Agent definitions and specifications
   â”‚   â”œâ”€â”€ agent_template.md      # Template for creating new agents
   â”‚   â”œâ”€â”€ artemis.md            # Mayor protocol, governance agent
   â”‚   â”œâ”€â”€ copilot.md            # Companion, elastic augmentation agent
   â”‚   â”œâ”€â”€ pack_rat.md           # Courier role, secure data transfer agent
   â”‚   â””â”€â”€ codex_daemon.md       # System anchor, memory interface agent
   â”‚
   â”œâ”€â”€ codex/                     # Core principles and philosophy
   â”‚   â””â”€â”€ manifesto.md          # Foundational principles document
   â”‚
   â”œâ”€â”€ core/                      # Core system components
   â”‚   â””â”€â”€ instructions/         # Instruction loading and caching
   â”‚
   â”œâ”€â”€ interface/                 # User-facing components
   â”‚   â”œâ”€â”€ codex_cli.py          # Main CLI for interacting with agents
   â”‚   â”œâ”€â”€ agent_router.yaml     # Keyword-based routing configuration
   â”‚   â””â”€â”€ translator_protocol.md # Communication encoding standards
   â”‚
   â”œâ”€â”€ launch/                    # Governance and release management
   â”‚   â”œâ”€â”€ open_source_covenant.md # Open source principles
   â”‚   â””â”€â”€ release_gatecheck.md   # Release validation criteria
   â”‚
   â”œâ”€â”€ memory/                    # Memory management frameworks
   â”‚   â”œâ”€â”€ trust_decay_model.md  # Trust scoring and decay mechanics
   â”‚   â”œâ”€â”€ memory_lawyer.md      # Memory validation protocols
   â”‚   â””â”€â”€ validation_simulations.md # Testing frameworks
   â”‚
   â”œâ”€â”€ sandbox_city/             # Simulation environment
   â”‚   â”œâ”€â”€ index.md              # Overview of sandbox environment
   â”‚   â”œâ”€â”€ semantic_zones.md     # Zone definitions
   â”‚   â””â”€â”€ networked_scripts/
   â”‚       â””â”€â”€ mail_delivery_sim.py # Secure mail transfer simulation
   â”‚
   â”œâ”€â”€ .gitignore                # Comprehensive ignore patterns
   â”œâ”€â”€ LICENSE                   # MIT License
   â”œâ”€â”€ README.md                 # User-facing documentation
   â”œâ”€â”€ requirements.txt          # Python dependencies (PyYAML>=6.0)
   â”œâ”€â”€ package.json              # Project metadata
   â”œâ”€â”€ pyproject.toml            # Python project configuration
   â””â”€â”€ uv.lock                   # Dependency lock file
   ```
   
   ---
   
   ## Agent System Architecture
   
   ### Agent Definition Framework
   
   All agents follow a standardized template (`agents/agent_template.md`) with these required fields:
   
   | Field | Description |
   |-------|-------------|
   | **Agent Name** | Unique identifier (e.g., "Artemis", "Pack Rat") |
   | **System Access Scope** | Boundaries of resource/data access |
   | **Semantic Role** | Primary function and purpose |
   | **Energy Signature** | Computational footprint (low/moderate/high-compute) |
   | **Linked Protocols** | Communication and operational protocols |
   | **Drift Countermeasures** | Mechanisms to prevent behavioral deviation |
   | **Trust Threshold Triggers** | Conditions that trigger trust re-evaluation |
   
   ### Current Agents
   
   #### 1. **Artemis** (Mayor Protocol, Governance)
   - **Role:** System overseer, governance, dispute resolution
   - **Access:** Full read access to agent/memory logs, write to governance protocols
   - **Energy:** Moderate, event-driven (policy violations, disputes, audits)
   - **Keywords:** `artemis`, `governance`, `policy`, `audit`, `dispute`, `review`
   
   #### 2. **Copilot** (Companion, Elastic Augmentation)
   - **Role:** Real-time assistant, contextual information provider
   - **Access:** Read current agent context and public memory, write to communication channels
   - **Energy:** Moderate, on-demand, scales with interaction
   - **Keywords:** `help`, `assist`, `explain`, `augment`, `clarify`, `suggest`
   
   #### 3. **Pack Rat** (Courier Role, Safe Transfer)
   - **Role:** Secure data transfer between agents/components
   - **Access:** Read/write to secure transfer zones, limited read to communication channels
   - **Energy:** Low-compute, transaction-based
   - **Keywords:** `transfer`, `send`, `receive`, `courier`, `data`, `secure`
   
   #### 4. **CompSuite** (formerly Codex Daemon - System Anchor, Memory Interface)
   - **Role:** System status monitoring, memory interface, configuration management
   - **Access:** System-level access to memory and configuration
   - **Energy:** Low-compute, continuous monitoring
   - **Keywords:** `memory`, `system`, `daemon`, `config`, `status`, `health`
   
   ### Agent Routing Mechanism
   
   The CLI uses keyword-based routing defined in `interface/agent_router.yaml`:
   
   1. User inputs command
   2. System matches keywords against agent definitions
   3. Command routed to appropriate agent
   4. Agent performs action within defined scope
   5. Results returned through interface
   
   ---

## Key Protocols & Models

### 1. **Trust Decay Model** (`memory/trust_decay_model.md`)

Dynamic trust evaluation framework with these components:

- **Initial Trust Score:** Baseline trust for new agents/memories/protocols
- **Decay Rate:** Natural erosion over time without reinforcement
- **Reinforcement Events:** Successful tasks, validations, protocol adherence increase trust
- **Negative Events:** Failures, violations, inconsistencies decrease trust
- **Trust Thresholds:** Trigger re-evaluation, restricted access, or increased scrutiny

**Applications:**
- Agent Trust: Influences resource access and reliability
- Memory Trust: Determines weight given to memory entries
- Protocol Trust: Confidence in protocol effectiveness

### 2. **Translator Protocol** (`interface/translator_protocol.md`)

Ensures consistent communication across languages and encoding systems:

- **Standard Encoding:** UTF-8 for all internal communications
- **Transliteration Rules:** Algorithms for converting text between writing systems
- **Language Detection:** Identify source language of incoming text
- **Error Reporting:** Automated alerts for encoding/transliteration issues
- **Human Review Loop:** Triggered for complex or ambiguous cases

### 3. **Artemis Transmission Protocol (ATP)**

Structured communication system with signal tags:

| Tag | Purpose |
|-----|---------|
| `#Mode:` | Overall intent (Build, Review, Organize, Capture, Synthesize, Commit) |
| `#Context:` | Brief mission goal or purpose |
| `#Priority:` | Urgency level (Critical, High, Normal, Low) |
| `#ActionType:` | Expected response (Summarize, Scaffold, Execute, Reflect) |
| `#TargetZone:` | Project/folder area for the work |
| `#SpecialNotes:` | Unusual instructions, warnings, or exceptions |

---

## Development Workflows

### Setting Up Development Environment

```bash
# 1. Clone repository
git clone <repository-url>
cd Artemis-City

# 2. Create virtual environment
python -m venv venv

# 3. Activate virtual environment
# On macOS/Linux:
source venv/bin/activate
# On Windows:
.\venv\Scripts\activate

# 4. Install dependencies
pip install -r requirements.txt
```

### Running the CLI

**Interactive Mode:**
```bash
python main.py
```

**Single Command Mode:**
```bash
python main.py "ask artemis about system status"
```

### Running Simulations

```bash
python sandbox_city/networked_scripts/mail_delivery_sim.py
```

### Testing Workflow

Currently, the project uses manual testing:
- Test CLI routing with various commands
- Run simulations to verify agent interactions
- Validate protocol compliance manually

**Note:** Test infrastructure is pending (`package.json` shows "no test specified")

---

## Coding Conventions

### Python Style Guidelines

1. **Documentation:**
   - Use Google-style docstrings for all public functions
   - Include Args, Returns, and Raises sections
   - Document module-level functionality at the top

2. **Code Organization:**
   - Keep functions focused and single-purpose
   - Use descriptive variable and function names
   - Maintain clear separation of concerns

3. **Error Handling:**
   - Fail gracefully with informative messages
   - Return empty/default values when appropriate
   - Log errors for debugging

4. **Configuration:**
   - Use YAML for configuration files
   - Keep configuration separate from code
   - Validate configuration on load

---

## Security Best Practices

###  Secret Protection

Artemis City follows strict security practices to protect sensitive information:

**Protected Patterns (via `.gitignore`):**
- Environment files: `.env`, `.env.*`, `.envrc`
- API keys: `*.key`, `*.pem`, `secrets/`
- Credentials: `credentials.json`, `auth.json`, `token.json`
- SSH keys: `id_rsa*`, `id_ed25519*`, etc.
- Cloud configs: `.aws/`, `.gcloud/`, `.azure/`
- Database files: `*.sqlite`, `*.db`, `*.dump`

**Required Practices:**

1. **Never commit secrets** - Use `.env` files (already in `.gitignore`)
2. **Use environment variables** - Load secrets from environment, not hardcode
3. **Generate strong keys** - Use `openssl rand -hex 32` or similar
4. **Rotate keys regularly** - Change API keys every 90 days
5. **Set file permissions** - `chmod 600 .env` to restrict access
6. **Use different keys per environment** - Dev keys â‰  Production keys

###  Development Security

**Do's:**
-  Use `.env.example` as template
-  Load secrets via `os.environ.get()`
-  Log "API key configured", not the actual key
-  Use HTTPS/TLS in production
-  Validate environment variables on startup

**Don'ts:**
-  Hardcode secrets in source code
-  Commit `.env` files to version control
-  Share API keys in chat/email/docs
-  Log secret values
-  Use weak or predictable keys

### ðŸš¨ If Secrets Are Exposed

1. **Immediately rotate** all compromised keys
2. **Revoke old keys** from all services
3. **Monitor logs** for unauthorized access
4. **Document the incident** for future prevention
5. **Review security practices** with the team

###  Security Resources

- **[SECURITY.md](SECURITY.md)** - Complete security guide with:
  - Environment variable setup
  - API key management
  - Pre-commit hooks
  - Production deployment
  - Incident response procedures

**Tools:**
- `setup_secrets.sh` - Automated secure environment setup
- `.env.example` - Environment variable template
- `.gitignore` - Comprehensive secret protection patterns

**External Resources:**
- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [GitHub Secret Scanning](https://docs.github.com/en/code-security/secret-scanning)
- [git-secrets](https://github.com/awslabs/git-secrets) - Prevent committing secrets

 **Remember**: Security is everyone's responsibility! Always err on the side of caution when handling sensitive data.

----
Authored by Prinston (Apollo) â€” Systems Architect, Ethics-Focused Ops
With Artemis (OpenAI) â€” AI dev partner 
As of November 2025|> Jules - Google Lab Claude - Anthropic